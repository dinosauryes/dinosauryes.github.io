<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>区块链学习</title>
      <link href="2021/04/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/04/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>2021华为区块链高校大赛<a id="more"></a></p><p><img src="https://i.loli.net/2021/04/26/qyGAUhtMF5pESfZ.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/qyGAUhtMF5pESfZ.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1619436832073"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础学习</title>
      <link href="2021/04/13/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/04/13/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>岁月悠悠 衰微只及肌肤，热忱抛却 颓废必至灵魂。**(已完结)**<a id="more"></a></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li>面向过程：当需要实现一个功能时，每一个具体的步骤都要亲力亲为，详细处理每一个细节</li><li>面向对象：当需要实现一个功能时，不关心具体的步骤，而是找一个以及具有该功能的，来帮我做</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);<span class="comment">//面向过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(array[i] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(array[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));<span class="comment">//面向对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>特点：面向对象符合我们思考习惯，可将复杂的事情简单化，并将我们从执行者变为指挥者，面向对象的语言中包含了三大基本特征，封装，继承，多态</li></ul><p>面向对象三大特征：</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>封装在Java中的体现</p><p>​    1.方法就是一种封装</p><p>​    封装就是将一些细节信息隐藏起来，对于外界不可见</p><p>​    2.关键字private封装</p><p>​    一旦使用private进行修饰，那么本类当中仍然可以随意访问，超出本类范围之外就不能再直接访问</p><p>​    间接访问private成员变量，就是定义一对Getter/Setter方法</p><p>注意事项：</p><p>​    1.当方法的局部变量和成员变量重名的时候，根据就近原则，优先使用局部变量，如果需要访问本类中的成员变量，需要使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名</span><br></pre></td></tr></table></figure><p>​    通过谁调用方法，谁就是this</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li>概述</li></ul><p>继承主要解决的问题是<strong>共性抽取</strong></p><p>子类可以拥有父类的内容，子类还可以拥有自己专有的内容</p><ul><li>格式</li></ul><p>在继承的关系中，子类就是一个父类，也就是说，子类可以被当作父类来看待</p><p>1.定义父类的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 父类名称</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定义子类的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名称 <span class="keyword">extends</span> 父类名称</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.重名</p><p>在父子类继承关系当中，如果成员变量重名，创建对象时有两种方式</p><p>​    直接通过子类对象访问成员变量</p><p>​    间接通过成员方法访问成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zi zi = <span class="keyword">new</span> Zi(); <span class="comment">// 等号左边是谁，就优先用谁</span></span><br><span class="line">System.out.println(zi.num) <span class="comment">// 没有则向上找</span></span><br><span class="line">System.out.println(fu.methodfu)</span><br><span class="line">System.out.println(zi.methodzi) <span class="comment">// 优先用此方法的成员变量,没有则向上找</span></span><br></pre></td></tr></table></figure><p>区分子类方法中重名的三种变量</p><p>​    局部变量：直接写</p><p>​    本类的成员变量：this.成员变量</p><p>​    父类的成员变量：<strong>super.成员变量</strong></p><p>4.继承中成员方法的访问特点</p><p>创建的对象是谁，就优先用谁，如果没有则向上找</p><p>5.方法的覆盖重写(Override)</p><p>​    概念： 在继承的关系中，方法的名称一样，参数列表也一样</p><blockquote><p>​                重写(Override)：方法的名称一样，参数列表也一样</p><p>​                重载(Overload)：方法的名称一样，参数列表不一样</p></blockquote><p>​    特点：创建的是子类对象，则优先用子类方法</p><p>6.继承中的构造方法的访问特点</p><p>​    1.子类构造方法中有一个默认隐含的“super( )”调用，所以一定是先调用的父类构造，后执行的子类构造</p><p>​    2.子类构造通过super关键字来调用父类重载构造</p><p>​    3.super的父类构造方法必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</p><p>​    4.子类必须调用父类构造方法，不写则赠送super()，写了则用写的super重载调用</p><ul><li>super关键字的三种用法</li></ul><p>1.在子类的成员方法中，访问父类的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.num <span class="comment">// 父类中的num成员变量</span></span><br></pre></td></tr></table></figure><p>2.在子类的成员方法中，访问父类的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.method <span class="comment">// 父类中的method成员方法</span></span><br></pre></td></tr></table></figure><p>3.在子类的构造方法中，访问父类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>() <span class="comment">// 第一行 仅一个 可重载</span></span><br></pre></td></tr></table></figure><ul><li>this关键字的三种用法</li></ul><p>super关键字用来访问父类内容，而this关键字用来访问本类内容</p><p>1.在本类的成员方法中，访问本类的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.num <span class="comment">// 本类中的成员变量</span></span><br></pre></td></tr></table></figure><p>2.在本类的成员方法中，访问本类的另一个成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.method() <span class="comment">// 本类的另一个成员方法</span></span><br></pre></td></tr></table></figure><p>3.在本类的构造方法中，访问本类的另一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>() <span class="comment">// 访问本类的另一个构造方法，可重载，必须是构造方法的第一个语句</span></span><br></pre></td></tr></table></figure><p>​    使用场景    </p><p>对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容</p><ul><li>Java继承的特点</li></ul><p>1.java语言是<strong>单继承</strong>的</p><p>一个类的直接父类只能有唯一一个</p><p>2.java语言可以<strong>多级继承</strong></p><blockquote><p>java.lang.Object是祖宗类</p></blockquote><p>3.一个子类的直接父类是唯一的，但是一个父类可以有很多个子类</p><ul><li>注意事项</li></ul><p>1.必须包装方法的名称相同，参数列表也相同，@Override写在方法前，用来检测是不是有效的正确覆盖重写</p><p>2.子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围，Object类是所有类的公共最高父类</p><blockquote><p>java.lang.String就是Object的子类</p></blockquote><p>3.子类方法的权限必须<strong>大于等于</strong>父类方法的权限修饰符，public &gt; protected &gt; (default) &gt; private</p><blockquote><p>(default)不是关键字default，而是什么都不写，留空</p></blockquote><p>4.无论成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类</p><p>5.super和this两种方法构造调用，不能同时使用</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul><li>概述</li></ul><p>extends继承或者implements接口实现，是多态的前提</p><p>一个对象拥有多种形态就是对象的多态性</p><ul><li>多态的格式和使用</li></ul><p>代码中体现多态性：<strong>父类引用指向子类对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类名称 对象名 = <span class="keyword">new</span> 子类名称();</span><br><span class="line">接口名称 对象名 = <span class="keyword">new</span> 实现类名称();</span><br></pre></td></tr></table></figure><p><strong>访问成员变量</strong></p><p>直接通过<strong>对象名称</strong>访问成员变量：看等号左边是谁，优先用谁，没有则向上找</p><p>间接通过<strong>成员方法</strong>访问成员变量：看该方法属于谁，优先用谁，没有则向上找</p><p><strong>多态中成员方法</strong></p><p>new谁则优先用谁，没有则向上找</p><p><strong>编译看左边，运行看右边</strong></p><p><strong>用处(好处)</strong></p><p>无论右边new的时候换成哪个子类对象，等号左边的调用方法都不会变化</p><p><strong>对象的上下转型</strong></p><p>​    向上转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类名称 对象名 = <span class="keyword">new</span> 子类名称();</span><br></pre></td></tr></table></figure><p>右侧创建一个子类对象，把它当作父类看待使用</p><p><strong>向上转型一定是安全的</strong> 从小范围转为大范围</p><p>弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容</p><p>​    向下转型(还原)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类名称 对象名 = (子类名称) 父类对象;</span><br></pre></td></tr></table></figure><p>将父类对象还原为子类对象</p><p>必须保证对象本来创建的时候，就是猫，才能向下转型成为猫</p><p>如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错</p><p>​    <strong>判断前面的对象能不能当后面类型的实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象 <span class="keyword">instanceof</span> 类名称 <span class="comment">// 将得到一个boolean值，可以判断前面的对象能不能当后面类型的实例</span></span><br><span class="line">    <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">        Dog dog = (Dog) animal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="匿名对象："><a href="#匿名对象：" class="headerlink" title="匿名对象："></a>匿名对象：</h5><p>只有右边的对象，无左边的名字和赋值运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in)</span><br><span class="line"><span class="keyword">int</span> num = sc.nextInt(); <span class="comment">// 普通使用方式</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="keyword">new</span> Scanner(System.in).nextInt(); <span class="comment">// 匿名对象的方式</span></span><br><span class="line">methodParam(<span class="keyword">new</span> Scanner(System.in)); <span class="comment">// 使用匿名对象来传递参数</span></span><br></pre></td></tr></table></figure><p>​    注意事项：</p><p>匿名对象只能使用唯一的一次，下次使用要再创建一个新对象</p><p>​    使用建议：</p><p>若确定一个对象只需要使用唯一的一次，就可以用匿名对象</p><h5 id="静态static关键字"><a href="#静态static关键字" class="headerlink" title="静态static关键字"></a>静态static关键字</h5><p>​    1.一旦使用static关键字这样的内容<strong>不再属于对象而是属于类</strong>，凡是本类的对象都都共享同一份</p><p>​    2.一旦使用static修饰成员方法，那么这就成了静态方法，静态方法不属于对象，而是属于类</p><p>​    3.若没有static关键字，那么必须首先创建对象，然后通过对象才能使用它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student obj = <span class="keyword">new</span> Student();</span><br><span class="line">obj.method(); <span class="comment">// 没有static关键字，先创建</span></span><br><span class="line">obj.methodStatic(); <span class="comment">// 正确，但不推荐，编译后会被Javac翻译为；类名称.静态方法名</span></span><br><span class="line">Student.methodStatic(); <span class="comment">// 正确且推荐</span></span><br></pre></td></tr></table></figure><p>​    4.静态不能直接访问非静态(内存中先有的静态内容，后有的非静态内容)</p><p>​    5.静态方法不能用this关键字</p><p>静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">// 静态代码块内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// 当第一次使用本类时，静态代码块执行唯一一次，执行优先于构造方法</span></span><br></pre></td></tr></table></figure><p>用途</p><p>用来一次性的对静态成员变量进行赋值</p><h5 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h5><p><strong>用于修饰类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被final修饰的类不能有任何子类(不能作为父类)</p><p><strong>用于修饰方法</strong></p><p>当final关键字来修饰一个方法的时候，这个方法就是最终方法，不能被覆盖重写</p><p><strong>用于修饰局部变量</strong></p><p>一旦使用final关键字来修饰局部变量，那么这个变量就不能进行更改</p><p>对于基本类型来说不可变是变量当中的数据不可改变</p><p>对于引用数据类型来说不可变是变量当中的地址值不可改变</p><p><strong>用于修饰成员变量</strong></p><p>对于成员变量来说，如果使用final关键字修饰那么这个变量也是不可变的</p><ol><li>由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值</li><li>对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值</li><li>必须包装类当中所有重载的构造方法，都最终会对final的成员变量进行赋值</li></ol><p><strong>四种权限修饰符</strong></p><table><thead><tr><th></th><th>public</th><th>protected</th><th>(default)</th><th>private</th></tr></thead><tbody><tr><td>同一个类</td><td>YES</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>同一个包</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>不同包子类</td><td>YES</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>不同包非子类</td><td>YES</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><p>(default)并不是关键字default 而是根本不写</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>如果一个事物内部包含另一个事物那么这就是一个类内部包含另一个类</p><p><strong>成员内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123;</span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 内部类名称</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内用外，随意访问；外用内，需要内部类对象</p><p>间接使用方式：在外部类的方法中，使用内部类；然后main只是调用外部类的方法</p><p>直接使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名称.内部类名称 对象名 = <span class="keyword">new</span> 外部类名称().new 内部类名称();</span><br></pre></td></tr></table></figure><ul><li>内部类的同名变量访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 内部类方法的局部变量，就近原则</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 内部类的成员变量</span></span><br><span class="line">            Systrm.out.println(Outer.<span class="keyword">this</span>.num); <span class="comment">// 外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>局部内部类的定义</li></ul><p>如果一个方法定义在一个方法内部的，那么这就是一个局部内部类</p><blockquote><p>局部：只有当前所属方法才能使用它，出了这个方法外面就不能用了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称</span>&#123;</span><br><span class="line">修饰符 返回值类型 外部类方法名称()&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 局部内部类名称</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个类的时候，权限符修饰规则：</p><ol><li>外部类：public / (default)</li><li>成员内部类：public / protected / (default) / private</li><li>局部内部类：什么都不能写</li></ol><p><strong>final问题</strong></p><p>局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是<em>有效final</em>(变量不能值不能改变)</p><blockquote><p>备注：从Java 8+开始只要局部变量事实不变，那么final关键字可以省略</p></blockquote><p>原因：1.new出来的在堆中</p><p>​           2.局部变量跟着方法走在栈内存中</p><p>​           3.方法运行结束后，立刻出栈，局部变量消失</p><p>​           4.new出来的对象会在堆当中持续存在，直到垃圾回收</p><p><strong>匿名内部类</strong></p><p>如果接口的实现类(或者父类的子类)只需要使用唯一的一次</p><p>那么在这种情况下可以省略掉该类的定义，改为使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称()&#123;</span><br><span class="line"><span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对格式“new 接口名称(){…}”的解析</p><p>​    1.new代表创建对象的动作</p><p>​    2.接口名称就是匿名内部类需要实现哪个接口</p><p>​    3.{…}是匿名内部类的内容</p><p>注意事项</p><p>​    1.匿名内部类在<strong>创建对象</strong>时只能使用唯一的一次</p><blockquote><p>如果希望多次创建对象，而且类的内容一样，那么必须使用单独定义的实现类</p></blockquote><p>​    2.匿名对象在<strong>调用方法</strong>的时候只能使用唯一的一次</p><blockquote><p>如果希望同一个对象调用多次方法，那么必须有对象名</p></blockquote><p>​    3.匿名内部类是省略了实现类/子类，但是匿名对象是省略了对象名称</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul><li>抽象方法</li></ul><p>如果父类当中的方法不确定如何{}方法体的实现，那么这种方法叫抽象方法(eg：图像周长)</p><p>在返回值类型前加上abstract并去掉大括号，直接分号结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">// 抽象方法，代表吃，具体吃什么不确定</span></span><br></pre></td></tr></table></figure><ul><li>抽象类</li></ul><p>抽象方法所在类，必须是抽象类才行，在class前加上abstract即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // 抽象类，里面可以有普通的成员方法</span></span><br></pre></td></tr></table></figure><ul><li>抽象方法和抽象类的使用</li></ul><p>1.不能直接创建new抽象类对象</p><p>2.必须用一个子类来继承抽象父类</p><p>3.子类必须覆盖重写抽象父类当中所有的抽象方法</p><blockquote><p>覆盖重写(实现)：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p></blockquote><p>4.创建子类对象进行使用</p><ul><li>注意事项</li></ul><p>1.抽象类不能创建对象，如果创建，编译无法通过而保持，只能创建其非抽象子类的对象</p><p>2.抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的</p><p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定时抽象类</p><p>4.抽象类的子类，必须重写抽象父类的所有的抽象方法，否则编译无法通过而报错，除非该子类也是抽象类</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>概述</li></ul><p>接口就是多个类的公共规范</p><blockquote><p>接口是一种引用数据类型。最重要的内容就是其中的抽象方法</p></blockquote><ul><li>定义格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line"><span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口内容可以包含：1.常量 2.抽象方法 3.默认方法 4.静态方法 5.私有方法</p><p>1.接口的<strong>抽象方法</strong></p><p><strong>定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(参数列表);</span><br><span class="line"><span class="keyword">public</span> 返回值类型 方法名称(参数列表);</span><br><span class="line"><span class="keyword">abstract</span> 返回值类型 方法名称(参数列表);</span><br><span class="line">返回值类型 方法名称(参数列表); <span class="comment">// 接口的抽象方法省略写法</span></span><br></pre></td></tr></table></figure><ol><li>接口当中的抽象方法，修饰符必须是两个固定的关键字： public abstract</li><li>这两个关键字修饰符可以选择性省略</li><li>方法的三要素可以随意定义</li></ol><p><strong>使用</strong></p><ol><li>接口不能直接使用，必须有一个<strong>实现类</strong>来实现该接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称</span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   2.接口的实现类必须覆盖重写(实现)接口中所有的抽象方法</p><blockquote><p>覆盖重写(实现) 去掉abstract关键字，加上方法体大括号</p></blockquote><p>   3.创建实现类的对象，进行使用</p><p>   4.注意：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个接口必须是抽象类</p><p>2.接口的<strong>默认方法</strong></p><p><strong>定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// 默认方法可以有方法体</span></span><br><span class="line"><span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123; <span class="comment">//接口的默认方法省略写法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接口当中的默认方法，可以解决接口升级的问题</li></ol><p><strong>使用</strong></p><ol><li>接口的默认方法，可以通过接口实现类对象，直接调用</li><li>接口的默认方法，也可以通过接口实现类进行覆盖重写</li></ol><p>3.接口的<strong>静态方法</strong></p><p><strong>定义</strong></p><p>从Java 8开始接口中允许当中允许定义静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">  <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123; <span class="comment">// 接口的静态方法省略写法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><ol><li>不能通过接口实现类的对象来调用接口当中的静态方法</li><li>通过接口名称直接调用其中的静态方法</li></ol><blockquote><p>接口名称.静态方法名(参数);</p></blockquote><p>4.接口的<strong>私有方法</strong></p><p><strong>定义</strong></p><ol><li>普通私有方法，解决多个默认方法之间重复代码问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">  <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   2.静态私有方法，解决多个静态方法之间重复代码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">  <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.接口<strong>常量</strong></p><p><strong>定义</strong></p><p>接口中可以定义“成员变量”，但是必须使用 public static final 三个关键字进行修饰</p><p>从效果上来看，这其实就是接口的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 常量名称 = 数据值;</span><br></pre></td></tr></table></figure><blockquote><p>一旦使用final关键字进行修饰，说明不可改变</p></blockquote><p><strong>使用</strong></p><ol><li>接口中的常量可省略 public static final关键字</li><li>接口中的常量必须进行赋值</li><li>接口中常量的名称使用完全大写的字母，用下划线进行分割</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口名称.常量名称</span><br></pre></td></tr></table></figure><p>6.接口之间的多继承</p><ol><li>类与类之间是单继承的，直接父类只有一个</li><li>类与接口之间是多实现的，一个类可以有多个接口</li><li>接口与接口之间是多继承的</li><li>多个父接口当中的抽象方法如果重复，没关系</li><li>多个父类接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，且带default关键字</li></ol><ul><li>注意事项</li></ul><p>1.接口没有静态代码块和构造方法</p><p>2.一个类的直接父类是唯一的，但一个类可以同时实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceA</span>,<span class="title">MyInterfaceB</span> </span>&#123;</span><br><span class="line"><span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可</p><p>4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类</p><p>5.如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</p><p>6.一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先用父类当中的方法</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h5 id="何为常量："><a href="#何为常量：" class="headerlink" title="何为常量："></a>何为常量：</h5><p>程序运行期间固定不变的量。</p><h5 id="常量的分类："><a href="#常量的分类：" class="headerlink" title="常量的分类："></a>常量的分类：</h5><p>​        1.字符串常量：用“  “引起来的部分，eg：”HelloWorld”（双引号中可为空）</p><p>​        2.整型常量：数字，无小数点，eg：100，-200，0</p><p>​        3.浮点数常量 : 数字，有小数点，eg：3.14，-56.00</p><p>​        4.字符常量：用’’引起来的部分，eg：’A’,’B’,’泽’（双引号中不为空）<em>（java中允许使用中文字符）</em></p><p>​        5.布尔常量：仅两种true,false</p><p>​        6.空常量：null，代表没有任何数据。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>整数型 byte short int long</p><p>浮点型 float double (近似值而非精确值)</p><p>字符型 char</p><p>布尔型 boolean</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1字节</td><td>-128~127</td></tr><tr><td>短整型</td><td>short</td><td>2字节</td><td>-32768~32767</td></tr><tr><td>整形</td><td>int（默认类型）</td><td>4字节</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td></tr><tr><td>长整型</td><td>long</td><td>8字节</td><td>-2<sup>63</sup>~2<sup>63</sup>-1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4字节</td><td>1.4013E-45~3.4028E+38</td></tr><tr><td>双精度浮点数</td><td>double（默认类型）</td><td>8字节</td><td>4.9E-324~1.7977E+308</td></tr><tr><td>字符型</td><td>char</td><td>2字节</td><td>0~65535</td></tr><tr><td>布尔类型</td><td>boolean</td><td>1字节</td><td>true,false</td></tr></tbody></table><p>注意事项：</p><p>1.数据范围与字节数不一定相关</p><p>2.浮点数当中默认类型是double。如果使用float类型，需要加上后缀F</p><p>3.整数中默认类型是int。如果一定要使用long类型，需要加上后缀L</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><p>字符串，数组，类(Scanner)，接口，Lambda</p><ul><li>使用步骤：</li></ul><p>1.导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包路径.类名称;</span><br></pre></td></tr></table></figure><p>如果需要使用的目标类和当前类位于同一个包下，则可以省略导包语句不写</p><p>只有java.lang包下的内容不需要导包，其他都需要import语句</p><p>2.创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名称 对象名 = <span class="keyword">new</span> 类名称</span><br></pre></td></tr></table></figure><p>3.使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员方法名</span><br></pre></td></tr></table></figure><h5 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><ul><li>自动类型转换</li></ul><p>特点：代码不需要特殊处理，自动完成</p><p>规则：数据范围从小到大</p><ul><li>强制数类型转换：</li></ul><p>特点：代码需要特殊格式处理，不能自动完成</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范围小的类型 范围小的变量名 &#x3D; （范围小的类型） 原本范围大的类型</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>1.强制类型转换不推荐使用，可能发生精度损失和数据溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) <span class="number">6000000000L</span>;</span><br><span class="line">System.out.println(num);<span class="comment">// 1705032704</span></span><br></pre></td></tr></table></figure><p>2.byte/short/<strong>char</strong>类型都可以发生数学运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> zifu = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(zifu + <span class="number">1</span>);<span class="comment">// 66</span></span><br></pre></td></tr></table></figure><p>3.byte/short/char类型运算时，首先提升成为int类型，再计算</p><p>4.Boolean类型不能发生数据类型转换</p><h5 id="ASCII表："><a href="#ASCII表：" class="headerlink" title="ASCII表："></a>ASCII表：</h5><table><thead><tr><th>ASCII值</th><th>控制字符</th></tr></thead><tbody><tr><td>48</td><td>0</td></tr><tr><td>65</td><td>A</td></tr><tr><td>97</td><td>a</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>何为变量：</p><p>​    程序运行期间，可以改变的量</p><p>注意事项：</p><p>​    1.如果创建多个变量，那么变量之间的名称不可以重复</p><p>​    2.对于float和long类型来说字母后缀F和L不要丢掉</p><p>​    3.如果使用byte和short类型的变量，右侧数据值范围不能超过左侧类型的范围</p><p>​    4.变量需要先赋值才能使用</p><p>​    5.变量使用不能超过作用域的范围</p><p>成员变量与局部变量的区别</p><p>​    1.定义的位置不一样</p><p>​        局部变量：在方法内部</p><p>​        成员变量：在方法外部，直接写在类中</p><p>​    2.作用范围不一样</p><p>​        局部变量：只有在方法中才可使用</p><p>​        成员变量：整个类通用</p><p>​    3.默认值不一样</p><p>​        局部变量：没有默认值，使用必须赋值</p><p>​        成员变量：有初始默认值(与数组一样)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    String name; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    4.内存的位置不一样</p><p>​        局部变量：位于栈内存，随方法进栈而诞生，随方法出栈而消失</p><p>​        成员变量：位于堆内存，随对象创建而诞生，随对象被垃圾回收而消失</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>定义类</p><ol><li>成员变量是直接定义在类中，在方法外面</li><li>成员方法不要写static关键字</li></ol><p>对象的创建及其使用</p><p>​    通常情况下，一个类不能直接使用，需要创建一个对象才能使用</p><ul><li><p>导包：指出所需要的类在什么位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名称.类名称;</span><br></pre></td></tr></table></figure><p>​       对于和当前类属于同一个包的情况，可以省略导包语句不写</p></li><li><p>创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名称 对象名 = <span class="keyword">new</span> 类名称();</span><br></pre></td></tr></table></figure></li><li><p>使用</p><ul><li>使用成员变量：对象名.成员变量名</li><li>使用成员方法：对象名.成员方法名()</li></ul><p>注意事项：如果成员变量没有赋值会有一个初始值，规则和数组一样</p></li></ul><p>类与对象的关系</p><ul><li>类是对一类事物的描述，是抽象的</li><li>对象是一类对象的实例，是具体的</li><li>类是对象的模板，对象是类的实例</li></ul><p>定义标准类：</p><ul><li><p>组成部分</p><p>1.所有成员变量都要使用private关键字修饰</p><p>2.为每一个成员变量编写一对儿Getter/Setter方法</p><p>3.编写一个无参数构造方法</p><p>4.编写一个全参数构造方法</p></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>何为方法：</li></ul><p>将一个功能抽取出来，定义在一个大括号内，形成一个单独的功能。需要这个功能时，进行调用，实现了代码的复用性。</p><ul><li>定义格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称 （参数类型 参数名称,...）&#123;</span><br><span class="line">方法体</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>return</li></ul><p>1.停止当前方法</p><p>2.将后面的返回值还给调用处 </p><p>3.return后面的返回值要与  <strong>返回值类型</strong>  保持一致</p><p>4.对于有返回值的方法，可以使用单独调用，打印调用和赋值调用</p><p>5.对于无返回值的方法，只能进行单独调用</p><p>6.对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己</p><p>7.无返回值，对于方法当中最后一行的return可以省略不写</p><p>8.一个方法中可以有多个return语句，但是必须保证同时只有一个会被执行</p><ul><li>注意事项：</li></ul><p>1.方法定义的先后顺序无所谓</p><p>2.方法定义不能产生嵌套包含关系</p><p>3.方法执行需要调用</p><ul><li>调用格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法名称（参数）;</span><br><span class="line">System.out.println(方法名称（参数）)</span><br><span class="line">数据类型 变量名称 = 方法名称（参数）</span><br></pre></td></tr></table></figure><h5 id="重载（OverLoad）"><a href="#重载（OverLoad）" class="headerlink" title="重载（OverLoad）"></a>重载（OverLoad）</h5><p>多个方法的名称一样，但参数列表不一样</p><p>方法重载相关因素：</p><p>1.参数个数</p><p>2.参数类型</p><p>3.参数的多类型顺序</p><p>方法重载无关因素：</p><p>1.参数名称</p><p>2.方法的返回值类型</p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>构造方法是专门用来创建对象的方法，当通过关键字new来创建对象时，其实就是再调用构造方法</p><p>创建格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称(参数类型 参数名称)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>1.构造方法的名称必须和所在的类名称完全一样</p><p>2.构造方法不要写任何返回值类型，包括void</p><p>3.构造方法不能return一个具体返回值</p><p>4.如果没有编写任何构造方法，编译器默认编一个构造方法，无参数、方法体</p><p>一旦编写，方法体不再赠送构造方法</p><p>5.构造方法可以进行重载(方法名称相同，参数列表不同)</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>可以同时存放多个数据值</p><ul><li>特点：</li></ul><p>1.数组是一种引用数据类型</p><p>2.数据当中的多个数据，类型必须统一</p><p>3.数组的长度在程序运行期间不能改变</p><ul><li>初始化方式：</li></ul><p>1.动态初始化（指定长度）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><p>2.静态初始化（指定内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[] &#123;元素<span class="number">1</span>,元素<span class="number">2.</span>.&#125;;</span><br><span class="line">数据类型[] 数组名称 = &#123;元素<span class="number">1</span>,元素<span class="number">2.</span>.&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><p>1.有new可以拆分成两个步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">11</span>,<span class="number">23</span>,<span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure><p>2.静态初始化省略格式不能拆分成两个步骤</p><p>3.若不确定数组当中的具体内容，用动态初始化，反之则用静态初始化</p><ul><li>使用数组中的元素</li></ul><p>1.直接打印数组名称，得到的是数组对应的内存地址哈希值</p><p>2.访问数组元素的格式 数组名称[索引值]（从0开始）</p><p>3.使用动态初始化数组时，其中的元素会自动拥有一个默认值</p><p>如果为整数类型，默认值为0</p><p>如果为浮点类型，默认值为0.0</p><p>如果为字符类型，默认为‘\u0000’</p><p>如果为布尔类型，默认为false</p><p>如果为引用类型，默认为null</p><ul><li>数组异常</li></ul><p>数组索引越界异常</p><p>空指针异常(没new创建)</p><ul><li>获取数组的长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xxx = 数组名称.length;</span><br></pre></td></tr></table></figure><ol><li><p>得到一个int数字，代表数组的长度</p></li><li><p>数组一旦创建，程序运行期间长度不可改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(array.length);<span class="comment">//3</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">System.out.println(array.length);<span class="comment">//5</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>数组的遍历输出</p><ul><li>概念：对数组中的每个元素进行逐一处理(使用循环与数组长度)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; 数组名.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//快捷码：数组名.length.fori</span></span><br></pre></td></tr></table></figure><p>数组作为方法的参数时，传递进去的是数组的地址</p></li></ul><p>数组作为方法的返回值时，返回的是数组地址</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h5 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h5><p>单if</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">     语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if - - else</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多if - - else</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>)&#123;</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h5><p>switch语句格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      语句体n+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch注意事项</p><p>1.多个case后面的数值不可以重复</p><p>2.swich后面的小括号中只能是：</p><p>基本数据类型：byte/short/char/int</p><p>引用数据类型：String字符串，enum枚举</p><p>3.switch语句前后顺序可以颠倒，且break语句可以省略（匹配到case后从当前位置向下执行，直到遇到break或default）</p><h5 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h5><p>1.初始化语句：在循环开始最初执行，并且只能做唯一一次。</p><p>2.条件判断：若成立，循环继续；反之则跳出循环。</p><p>3.循环体：重复要做的事情内容，若干行语句。</p><p>4.布进语句：每次循环之后的扫尾工作。</p><p>for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始表达式; 布尔表达式; 步进表达式)&#123;</span><br><span class="line">循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while循环</p><p>while格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span> (条件判断)&#123;</span><br><span class="line">循环体;</span><br><span class="line">步进语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do - - while 循环</p><p>do - - while 格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">循环体</span><br><span class="line">    步进语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件判断);</span><br></pre></td></tr></table></figure><p>三种循环的区别</p><p>1.若条件判断从未满足，for和while循环执行0次，do-while循环至少执行一次</p><p>2.for循环的变量在小括号中定义，仅能在循环中使用。while循环和do-while循环初始化语句在括号外，循环结束后可以继续使用 </p><p>3.凡是次数确定的场景多用for循环，否则用while循环</p><p>break关键字</p><p>1.可以用在switch语句中，一旦执行，整个switch语句立刻结束</p><p>2.可以用在循环语句中，一旦执行，整个循环语句立刻结束，打断循环</p><p>continue关键字</p><p>1.一旦执行，立刻跳过当前次循环内容，马上开始下一次循环</p><h2 id="JAVA的内存划分"><a href="#JAVA的内存划分" class="headerlink" title="JAVA的内存划分"></a>JAVA的内存划分</h2><p>1**.栈(Stack)<strong>：存放方法中的局部变量，</strong>运行方法一定要在栈中**</p><p>​        局部变量：{}内的变量，一旦超出作用域，立刻从栈内存中消失</p><p>2.<strong>堆(Heap)：new出来的，在堆内存</strong></p><p>​        堆内存里的东西都有一个地址值：16进制</p><p>​        堆内存里面的数据，都有默认值：</p><p>​                若为整数    默认为0</p><p>​                若为浮点数        默认为0.0</p><p>​                若为字符        默认为‘\u0000’</p><p>​                若为布尔        默认为false</p><p>​                若为引用类型        默认为null</p><p>3.方法区(Method Area)：存储.class相关信息，包含方法的信息</p><p>4.本地方法栈(Native Method Stack)：与操作系统相关</p><p>5.寄存器(pc Register)：与CPU相关 </p><h2 id="API-Application-Programming-Interface"><a href="#API-Application-Programming-Interface" class="headerlink" title="API(Application Programming Interface)"></a>API(Application Programming Interface)</h2><p>概述:Java API程序员小词典</p><h5 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h5><ul><li>何为Scanner类</li></ul><p>可以解析基本类型和字符串的简单文本扫描器(实现键盘输入到程序中)</p><ul><li>Scanner的一般步骤</li></ul><p>1.导包</p><p>2.创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p>​    System.in(键盘输入)</p><p>3.使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员方法名</span><br><span class="line"><span class="keyword">int</span> num = sc.nextInt(); <span class="comment">// 获取键盘输入的一个int数字</span></span><br><span class="line">String str = sc.next(); <span class="comment">// 获取键盘输入的一个字符串</span></span><br></pre></td></tr></table></figure><h5 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h5><ul><li>何为Random类：</li></ul><p>用于生成随机数字的包</p><ul><li>Random的一般步骤：</li></ul><p>1.导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random</span><br></pre></td></tr></table></figure><p>2.创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure><p>3.使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = r.nextInt(); <span class="comment">// 获取一个随机的int数字,有正负两种</span></span><br><span class="line"><span class="keyword">int</span> num = r.nextInt(<span class="number">3</span>); <span class="comment">// 获取一个随机的int数字(参数代表范围，左闭右开区间) 范围为[0,3)</span></span><br><span class="line"><span class="keyword">int</span> num = r.nextInt(n)+<span class="number">1</span>; <span class="comment">// 取值范围为[1,n]</span></span><br></pre></td></tr></table></figure><h5 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h5><ul><li>何为ArrayList类</li></ul><p>可以实现数组的大小可变，操作内部的储存</p><ul><li><E> </E></li></ul><p><E>表示泛型(装在集合当中的所有元素，全部都是统一的类型(引用类型而非基础类型))</E></p><ul><li>ArrayList的一般步骤</li></ul><p>1.导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure><p>2.创建</p><p>从JDK1.7+开始，右侧的尖括号内部可以不写写内容，但&lt;&gt;本身还是要写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;数据类型&gt; list = <span class="keyword">new</span> Arraylist&lt;&gt;();</span><br></pre></td></tr></table></figure><p>3.使用</p><p>​    1.向集合中添加元素: add</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;赵四&quot;</span>); <span class="comment">// 向集合里添加一些数据</span></span><br><span class="line">System.out.println(list); <span class="comment">// [张三，赵四]</span></span><br><span class="line"><span class="keyword">boolean</span> success = list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;添加的动作是否成功：&quot;</span>+ success); <span class="comment">// 添加的动作是否成功：true</span></span><br></pre></td></tr></table></figure><p>​    2.从集合中获取元素：get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = list.get(<span class="number">1</span>); <span class="comment">// 索引值从0开始</span></span><br><span class="line">System.out.println(<span class="string">&quot;第一号索引位置：&quot;</span>+ name); <span class="comment">// 第一号索引位置：赵四</span></span><br></pre></td></tr></table></figure><p>​    3.从集合中删除元素：remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String whoremove = list.remove(<span class="number">1</span>); <span class="comment">// 返回值是被删除的人</span></span><br><span class="line">System.out.println(<span class="string">&quot;被删除的人是：&quot;</span> + whoremove); <span class="comment">// 赵四</span></span><br><span class="line">System.out.println(list); <span class="comment">// [张三, 王五]</span></span><br></pre></td></tr></table></figure><p>​    4.获取集合的元素个数：size</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line">System.out.println(size); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>5.遍历集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           System.out.println(list.get(i));</span><br><span class="line">       &#125; <span class="comment">// 快捷键 list.fori</span></span><br></pre></td></tr></table></figure><p>​    6.ArrayList集合存储基本数据类型、</p><p>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的<strong>包装类</strong></p><p>包装类：引用类型，包装类都位于java.lang包下，不需要导包</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; listA = <span class="keyword">new</span> ArrayList;</span><br><span class="line">listA.add(<span class="number">100</span>);</span><br><span class="line">System.out.println(listA.get(<span class="number">0</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>从JDK1.5开始，支持自动装箱，自动拆箱</p><p>​    自动装箱：基本类型–&gt;包装类型</p><p>​    自动拆箱：包装类型–&gt;基本类型</p><ul><li>ArrayList注意事项</li></ul><p>对于ArrayList来说，直接打印得到的不是地址值，而是内容，若内容为空得到的时：[ ]</p><h5 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h5><ul><li>概述</li></ul><p>Java程序中所有字符串字面值(如“abc”)都作为此类的实例实现</p><ul><li>String类的一般步骤</li></ul><p>1.特点</p><p>​    1.字符串是常量，内容永不可变</p><p>​    2.字符串可共享使用</p><p>​    3.字符串效果相当于是char[ ]字符数组，但是底层原理是byte[ ]字节数组</p><p>​    4.在java.lang.String包下不用导包</p><p>2.创建</p><p>常见3+1种方式</p><p>​    三种构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> <span class="comment">// 创建一个空白字符串，不含有任何内容</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] array)</span> <span class="comment">// 根据字符数组的内容，来创建对象的字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(bytr[] array)</span> <span class="comment">//根据字节数组的内容，来创建对应的字符串</span></span></span><br></pre></td></tr></table></figure><p>​    一种直接创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 右边直接用</span></span><br></pre></td></tr></table></figure><p>3.使用</p><p>​    1.字符串内容的比较( 直接==是进行对象的地址值比较)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>; <span class="comment">// 任何对象都能用Object进行接受</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(Object obj)</span></span>; <span class="comment">// 忽略大小写</span></span><br><span class="line">String str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(charArray);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(str2.equals(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.printlb(<span class="string">&quot;Hello&quot;</span>.equals(str1)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 推荐：&quot;abc&quot;.equals(str)  不推荐：str.equals(&quot;abc&quot;)  原因是容易发生空指针异常</span></span><br></pre></td></tr></table></figure><p>​    2.字符串获取相关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">// 获取字符串当中含有的字符个数，拿到字符串长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">// 将当前字符串和参数字符串拼接成为返回值新的字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 获取指定索引(从零开始)位置的单个字符 如果没有返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> <span class="comment">// 查找字符串在本字符串当中首次出现的索引位置</span></span></span><br></pre></td></tr></table></figure><p>​    3.字符串截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 截取从参数位置一直到字符串末尾，返回新字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> <span class="comment">// 截取从begin开始到end结束中间的字符串  [begin,end)    </span></span></span><br></pre></td></tr></table></figure><p>​    4.相关转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() <span class="comment">// 将当前字符串拆分成为单个字符数组作为返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() <span class="comment">// 获得当前字符串底层的字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence oldString,CharSequence newString)</span> <span class="comment">// 将所有出现的老字符串替换成为新的字符串，返回替换之后的新字符串</span></span></span><br></pre></td></tr></table></figure><p>​    5.字符串分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex) <span class="comment">// 按照参数的规则，将字符串切分成为若干部分</span></span><br><span class="line">    <span class="comment">//注意事项：split方法的参数是&quot;正则表达式&quot;，若按照英文句点&quot;.&quot;进行切分，必须写&quot;\\.&quot;(l)</span></span><br></pre></td></tr></table></figure><ul><li>注意事项：</li></ul><p>1.对于引用数据类型来说， ==比较的是地址值</p><p>2.双引号直接写的字符串在常量池种，new不在池中</p><h5 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h5><ul><li>概述</li></ul><p>提供一些与数组相关的工具类，提供了大量<strong>静态方法</strong>，用来实现数组常见的操作(静态方法不用new，直接类名称.方法名)</p><ul><li>Arrays使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(数组)</span> <span class="comment">// 将参数数组变成字符串(按照默认格式：[元素1, 元素2, ...])</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(数组)</span> <span class="comment">// 按照默认升序(从小到大)对数组进行排序</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* 1.如果是数值，sort默认按照升序从小到大</span></span></span><br><span class="line"><span class="function"><span class="comment">       2.如果是字符串，sort默认按照字母升序</span></span></span><br><span class="line"><span class="function"><span class="comment">       3.如果是自定义类型，那么这个自定义的类需要有Comparable或Comparator接口的支持 */</span></span></span><br></pre></td></tr></table></figure><h5 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h5><ul><li>概述</li></ul><p>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算线管的操作，多为静态方法。</p><ul><li>Math类使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> num)</span> <span class="comment">// 获取绝对值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> num)</span> <span class="comment">// 向上取整</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> num)</span> <span class="comment">// 向下取整[非四舍五入]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> num)</span> <span class="comment">// 四舍五入</span></span></span><br><span class="line"><span class="function">    Math.PI <span class="comment">// d</span></span></span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Alt+Enter</td><td>导入包，自动修正代码</td></tr><tr><td>Ctrl+Y</td><td>删除光标所在行</td></tr><tr><td>Ctrl+D</td><td>复制光标所在行内容，插入光标位置下面</td></tr><tr><td>Ctrl+Alt+L</td><td>格式化代码（使代码变工整）</td></tr><tr><td>Ctrl+Shift+/</td><td>多行注释，再按取消注释</td></tr><tr><td>Ctrl+/</td><td>单行注释，再按取消注释</td></tr><tr><td>Alt+Ins</td><td>自动生成代码，toString,get,set等方法</td></tr><tr><td>Alt+Shift+上下箭头</td><td>移动当前代码行</td></tr><tr><td>Shift+F6</td><td>改变与之有关的所有参数名</td></tr></tbody></table><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+方法名右键</td><td>查看方法源代码</td></tr><tr><td>Shift+F6</td><td>重命名光标所在的局部变量，重构名字</td></tr><tr><td>Fn+Alt+Insert</td><td>自动补全标准类</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="IDEA常用快捷代码"><a href="#IDEA常用快捷代码" class="headerlink" title="IDEA常用快捷代码"></a>IDEA常用快捷代码</h2><table><thead><tr><th>x.fori</th><th>for(int i = 0; i &lt; 5; i++)</th></tr></thead><tbody><tr><td>pswm</td><td>public static void main(String args)</td></tr><tr><td>sout</td><td>System.out.println()</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录Hexo博客的创建</title>
      <link href="2021/01/06/%E8%AE%B0%E5%BD%95Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>2021/01/06/%E8%AE%B0%E5%BD%95Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>​       经历了数次失败，现开门见山的讲述使用Github 和 Hexo 搭建属于自己的博客</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>通过官网下载或下载学长发的安装包解压Node.js安装包即可</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>通过官网下载或下载学长发的安装包解压GIT安装包即可</p><h6 id="检查GIT是否安装成功"><a href="#检查GIT是否安装成功" class="headerlink" title="检查GIT是否安装成功"></a>检查GIT是否安装成功</h6><p>找到GIT对应文件夹</p><p>找到git-bash并打开</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>若有提示对应的版本号，则Git安装成功！</p><h5 id><a href="#" class="headerlink" title></a></h5><h4 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h4><p>进入GitHub官网 点击 sign up注册账号（人机验证或许需要科学上网？可通过安装浏览器插件解决）</p><p>此时GitHub会向你的邮箱发送验证电子邮箱地址，点击确认。</p><h4 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h4><p>点击new repository 注意repository name 是</p><p>你的github账号名.github.io</p><p>勾选Add a README file</p><p>点击creating repository.创建仓库</p><h3 id="安装本地Hexo"><a href="#安装本地Hexo" class="headerlink" title="安装本地Hexo"></a>安装本地Hexo</h3><h4 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h4><p>首先在你想要在本地放blog的地方新建blog文件夹</p><p>并对文件夹右键</p><p>点击Git Bash Here(功能类似与cd blog)</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf *  （此语句的作用是清空当前目录下的所有东西,谨慎使用，一定要在对应的blog下。）</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h4 id="检验效果（预览blog）"><a href="#检验效果（预览blog）" class="headerlink" title="检验效果（预览blog）"></a>检验效果（预览blog）</h4><p>下面来检验一下效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>若git提示下列代码则说明成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看预览效果（Ctrl+C可以关闭预览）</p><p>如果显示预览效果是 404 那么大概率是端口被占用了</p><p>再换一个端口试试看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure><p>此时本地blog就搭建好了，但只能自己访问。我们需要将blog部署到github上，来让更多人访问到我们的blog。</p><h3 id="将hexo部署至github"><a href="#将hexo部署至github" class="headerlink" title="将hexo部署至github"></a>将hexo部署至github</h3><h4 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h4><p>对blog文件夹右键，点击Git Bash Here 输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your email@example.com&quot; </span><br></pre></td></tr></table></figure><p>注：”your <a href="mailto:&#x65;&#x6d;&#x61;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x65;&#x6d;&#x61;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>“ 是你的邮箱，eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;</span><br></pre></td></tr></table></figure><p>接下来连续按三次回车，会出现一系列字符串</p><p>运行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>将密钥保存至粘贴板</p><p>或打开.ssh/id_rsa.pub文件直接复制密钥</p><h4 id="在github账户上添加密钥"><a href="#在github账户上添加密钥" class="headerlink" title="在github账户上添加密钥"></a>在github账户上添加密钥</h4><p>此处因没有图片 自行百度</p><h4 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h4><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>接着会提示你</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want to continue connecting(yes&#x2F;no)?</span><br></pre></td></tr></table></figure><p>输入yes</p><p>若提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi 你的用户名！You&#39;ve successfully....</span><br></pre></td></tr></table></figure><h4 id="配置git个人信息"><a href="#配置git个人信息" class="headerlink" title="配置git个人信息"></a>配置git个人信息</h4><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;此处填你的用户名&quot;  </span><br><span class="line">git config --global user.email  &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>此时本机已经成功与github连接</p><h3 id="将本地的-Hexo-文件更新到-Github-中"><a href="#将本地的-Hexo-文件更新到-Github-中" class="headerlink" title="将本地的 Hexo 文件更新到 Github 中"></a>将本地的 Hexo 文件更新到 Github 中</h3><h4 id="修改-config-yml文件配置"><a href="#修改-config-yml文件配置" class="headerlink" title="修改_config.yml文件配置"></a>修改_config.yml文件配置</h4><p>用编程软件打开_config.yml（记事本也可以）</p><p>我这里用的是vs</p><p>找到关键字deploy(在最下面)</p><p>注意：”：“后要空一格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:dinosauryes&#x2F;dinosauryes.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>repository比葫芦画瓢将dinosauryes改为自己的github用户名</p><h4 id="安装deployer"><a href="#安装deployer" class="headerlink" title="安装deployer"></a>安装deployer</h4><p>在命令框中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在网址输入https://你的GitHub用户名.github.io  完成</p><h3 id="心得：不要轻言放弃！！！我重新安装了三次终于成功了。"><a href="#心得：不要轻言放弃！！！我重新安装了三次终于成功了。" class="headerlink" title="心得：不要轻言放弃！！！我重新安装了三次终于成功了。"></a>心得：不要轻言放弃！！！我重新安装了三次终于成功了。</h3><h1 id="岁月悠悠-衰微只及肌肤"><a href="#岁月悠悠-衰微只及肌肤" class="headerlink" title="岁月悠悠 衰微只及肌肤"></a>岁月悠悠 衰微只及肌肤</h1><h1 id="热忱抛却-颓废必至灵魂"><a href="#热忱抛却-颓废必至灵魂" class="headerlink" title="热忱抛却 颓废必至灵魂"></a>热忱抛却 颓废必至灵魂</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/06/hello-world/"/>
      <url>2021/01/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
