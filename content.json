{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://dinosauryes.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"数据库笔记","date":"2021-10-24T00:23:32.257Z","updated":"2018-04-20T12:26:58.000Z","comments":true,"path":"2021/10/24/数据库笔记/","link":"","permalink":"http://dinosauryes.github.io/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据库笔记第一章模型分为两类：概念模型，逻辑模型和物理模型 唯一标识实体的的属性集称为码 数据库的三级模式：外模式，模式，内模式 模式：逻辑模式是数据库中全体数据的逻辑结构和特征的描述 外模式：子模式或用户模式，数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图与某一应用有关的数据的逻辑表示。 内模式：储存模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。 逻辑模型：层次模型，网状模型，关系模型，面对对象数据模型，对象关系数据模型，半结构化数据模型。 元组是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为记录。 第二章定义： 域：是一组具有相同数据类型的值的集合。 笛卡尔积 关系 主码，非主属性，非码属性 基本关系的六条性质： 列是同质的。 不同的列可出自同一个域，称其中的每一个列为一个属性，不同的属性要给予不同的属性名。 列的顺序无所谓，即列的次序可以任意交换。 任意两个元组的候选码不能取相同的值。 行的顺序无所谓，即行关系的次序可以任意交换。 分量必须取原子值，即每一个分量都必须是不可分的数据项。 关系完整性：实体完整性，参照完整性。 实体完整性：若A是基本关系R的主属性，则A不可以取空值。 关系运算：选择，投影，连接，除运算等。 选择：从表中某个属性之中选择出特定的部分或者个体(行) 投影：从属性列中罗列出不重复的选项(列) 连接：将表连接起来，就是高级版的笛卡儿积，等值连接就是把有共同属性且相等的拉出来，自然连接就是在自然连接的基础上把其中重复的属性再去掉，非等值连接就是按照其中的规定连接起来(行，列) 除：类似做成两个字典，一个字典的值对应另一个字典的键值，如果能够在第一个字典中找到相应的键值，那么就把第一个字典的键值罗列出来(行，列) 第三章模式分为三级模式结构。外模式包括若干视图和部分基本表，数据库模式包括若干基本表，内模式包括若干存储文件。 schema可以理解为命名空间，与database处于同一级别。create schema 模式名字 authorization 用户名字 （定义）drop schema 模式名字 create table 表名字(表的具体定义) drop table 表名字 123456alter table 表名字add column 数据类型 完整性约束add 表级完整性约束drop column 列名drop constraint 完整性约束名 restrict|cascadealter column 列名 数据类型 mysql改变表的结构：alter table 名字 change 列 列 属性 删除基本表 1drop table 表名 restrict|cascade 前者有限制条件，不能有视图，触发器，不能有存储过程或函数，有则不能删除后者没有限制条件，如果有，则全部删除。 建立索引可以加快查询速度。B+树索引，散列索引，位图索引 1create unique cluster index 索引名 on 表名(列名 次序……) 次序指的是desc降序，asc升序 1删除索引 drop index on tableName 修改索引 alter index rename to 表名 经测试在mysql貌似不支持对索引的修改，索引应该及时地repaire或者删除重新建立 数据库查询 12345select all|distinct 目标列（目标列表达式）from 表名或者视图名 (select 语句 as 别名)where 条件表达式group by 列名 having 条件表达式order by 列名 asc|desc 字符匹配 谓词like’匹配串‘通配符 _ 代表单个任意字符 % 代表任意长度（可以为0）的字符串当选择为空的时候，必须使用is而不能使用= 聚集函数count(*) count(列名) sum,avg,max,min注意：where子句中是不能用聚集函数作为条件表达式的，聚集函数只能用于select 子句和group by中的having子句中。 连接查询等值连接查询，自然连接查询，非等值连接查询，自身连接查询，外连接查询，复合条件连接查询那目标列中的重复的属性去掉为自然连接将一个表取别名，则为自身连接外连接则为，将两者相同的属性进行连接，没有的属性用NULL补全。左连接则保留左边关系，右连接保留右边关系。查询可加入exist 和 not exist进行限制，只关心内层查询是否有返回值 集合查询并，交，差union将查询结果进行合并的时候，自动去掉重复元素。如果保留重复元素，使用union all。Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序；Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。 插入子查询 1insert into 表名 属性 子查询 修改数据 123update 表名set 列名 = 表达式名 where 条件表达式 删除数据 123delete from 表名where 条件表达式 视图 12345678create view 视图名 （列名……）&#123;这里的列名可以选择，起不起别名&#125;as 子查询with check option 检查表示对视图进行update，insert，delete操作的时候要保证更新、插入或者删除 视图在msql显示在table中，但是删除的时候必须删除view而不可以删除table 删除视图drop view 视图名 （cascade）级联删除可以将该视图和它导出的视图都删除 更新视图由于视图是不存在的虚表，所以对视图的更新最终都会转化为对基本表的更新。 规定： 若视图是由两个以上的基本表导出的，则此视图不允许更新 若视图的字段来自字段表达式或常熟，则不允许对此视图进行insert和update操作，但允许进行delete操作 若视图的字段来自聚集函数，则此视图不允许更新 若视图定义中含有group by子句，则此视图不允许更新 若视图定义中含有distinct短语，则此视图不允许更新 若视图定义中有嵌套查询，并且内层查询的from子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。 一个不允许更新的视图上定义的视图也不允许更新 视图的作用 视图可以简化用户的操作 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 适当利用视图可以更清晰地表达查询 第四章授权 123456grant 权限on 对象类型 对象名to 用户 【with grant option】如果指定了最后一句，则获得该权限的用户还可以把这种权限再授予其他用户。 不允许循环授予权限 1234567收回权限revoke 权限on 对象类型 对象名from 用户 创建用户create user ’名字‘@’主机‘ identified by ‘密码’删除用户drop user ’名字‘@’主机‘ 第五章定义实体完整性：即定义主码，分为列级定义主码，表级定义主码 定义参照完整性：即定义外码 约束条件：1. 不允许取空值 2. 列值唯一 3. 用check短语指定列值应该满足的条件 断言： create assertion 断言名 check子句 断言创建以后，任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。 创建存储过程 123CREATE PROCEDURE sp_name ([ proc_parameter ]) [ characteristics..] routine_body proc_parameter指定存储过程的参数列表，列表形式如下：[IN|OUT|INOUT] param_name type 其中in表示输入参数，out表示输出参数，inout表示既可以输入也可以输出；param_name表示参数名称；type表示参数的类型 该类型可以是MYSQL数据库中的任意类型 触发器 12345CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmtbegin…………end 其中after指动作发生之后在进行操作，而before指的是动作发生之前进行的操作。 before失败，不会触发触发器的效果，after失败的话，会进行事务回滚。 分为行级和语句级触发器，语句级为for each statement(MYSQL不允许语句级的触发器) 第六章数据依赖是一个关系内部属性与属性之间的一种约束关系。是通过属性之间的值的相等与否体现出来的数据间的相关联系。最重要的为函数依赖和多值依赖 平凡的函数依赖是必然成立的。 $X\\rightarrow Y$，但 $Y\\nsubseteq X$，则称$X \\rightarrow Y$是非平凡的函数依赖。 x称为决定因素。 如果$X \\rightarrow Y$，并且对于x的任何一个真子集x’，都有$X’\\nrightarrow Y$，则y对x完全函数依赖，记做 $ X\\stackrel{F}{\\longrightarrow} Y$ 如果$X\\rightarrow Y$ ，但Y不完全函数依赖于X，则称Y对于X部分函数依赖，记做$X\\stackrel{P}{\\longrightarrow} Y$ 传递函数依赖中，$X\\nrightarrow Y$是为了不要变成直接函数依赖。 范式 ：关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。 2NF： 若$R\\in 1NF$ ，且每一个非主属性完全函数依赖于任何一个候选码，则$R\\in 2NF$ 3NF： 每一个非主属性既不传递依赖于码，也不部分依赖于码。 BCNF：每一个决定因素都包含码。 所有非主属性对每一个码都是完全函数依赖 所有主属性对每一个不包含它的码也是完全函数依赖 没有任何属性完全函数依赖于非码的任何一组属性 注意： 这里指的都是非主属性 3NF——只消除非主属性对主属性的传递依赖；BCNF——消除所有属性对主属性的传递依赖。 函数依赖就像是函数一样，自变量唯一确定值；多值依赖则不一样，自变量可能决定多个值。 多值依赖的性质： 多值依赖具有对称性 多值依赖具有传递性 函数依赖可以看作是多值依赖的特殊情况 若$X\\rightarrow \\rightarrow Y$ ，$X\\rightarrow \\rightarrow Z$ ,则$X\\rightarrow \\rightarrow YZ$ 若$X\\rightarrow \\rightarrow Y$，$X\\rightarrow \\rightarrow Y$，则$X\\rightarrow \\rightarrow Y\\cap Z$ 若$X\\rightarrow \\rightarrow Y$，$X\\rightarrow \\rightarrow Z$，则$X\\rightarrow \\rightarrow Y-Z$，$X\\rightarrow \\rightarrow Z-Y$ 函数依赖与多值依赖的区别： 多值依赖是元组产生依赖，函数依赖是相等产生依赖。 多值依赖的有效性与属性集的范围有关，而函数依赖的有效性则与属性集的范围无关。 若X$\\rightarrow$Y在R(U)上成立，则对于$\\forall$Y′$\\subseteq$Y，X$\\rightarrow$Y′均成立。而若X$\\rightarrow$$\\rightarrow$Y在R(U)上成立，则不能断言对于Y′$\\subseteq$Y，有X$\\rightarrow$$\\rightarrow$Y ′成立。（即函数依赖是相等依赖，多值依赖是元组产生依赖） 在多值依赖的范围内，属于4NF的关系模式已达到了最高的规范化程度 （！！！前提为简单的二元分解）R2&lt;U2 , F2&gt;是具有无损连接性的分解的充分必要条件是：(U1∩U2$\\rightarrow$U1-U2)$\\in F^+$或者(U1∩U2$\\rightarrow$U2-U1)$\\in F^+$，除此以外还可以使用表格法来判断是否是无损连接。 模式分解的若干结论： 分解具有无损连接性和分解保持函数依赖是两个互相独立的标准。具有无损连接性的分解不一定保持函数依赖，保持函数依赖的分解不一定具有无损连接性。一个关系模式的分解可能有三种情况 若要求分解具有无损连接性，那么分解后的模式一定能达到BCNF 若要求分解保持函数依赖，那么分解后的模式总可以达到3NF，但不一定能达到BCNF 若要求分解既具有无损连接性，又保持函数依赖，则分解后的模式可以达到3NF，但不一定能达到BCNF 求解最小函数依赖集分三步: 将F中的所有依赖右边化为单一元素 去掉F中的所有依赖左边的冗余属性. 去掉F中所有冗余依赖关系. 闭包的运算过程： 设最终将成为闭包的属性集是Y，把Y初始化为X 检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将其加入到Y中 重复第二步，直到没有属性可以添加到属性集Y中为止。 最后得到的Y就是X＋ 第七章ER图规定： 实体型用矩形表示 属性用椭圆形表示 联系用菱形表示 ER图转化为关系模型： 一个1：1联系可以转化为一个独立的关系模型，也可以与任意一端对应的关系模型合并 一个1：n联系可以转化为一个独立的关系模型，也可以与n端对应的关系模型合并 一个m：n联系转换为一个关系模型，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分 三个或三个以上实体间的一个多元联系可以转换为一个关系模式 具有相同码的关系模式可以合并 疑问： 大前提为多个表，如果触发器定义完之后，往里面插入信息的时候，会破坏触发器，怎么办？1","categories":[],"tags":[]},{"title":"JavaFX桌面开发_GUI","slug":"JavaFX桌面开发-GUI","date":"2021-06-21T07:12:57.000Z","updated":"2021-06-21T07:12:57.792Z","comments":true,"path":"2021/06/21/JavaFX桌面开发-GUI/","link":"","permalink":"http://dinosauryes.github.io/2021/06/21/JavaFX%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91-GUI/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"区块链学习","slug":"区块链学习","date":"2021-04-26T11:20:44.000Z","updated":"2021-05-19T04:42:19.589Z","comments":true,"path":"2021/04/26/区块链学习/","link":"","permalink":"http://dinosauryes.github.io/2021/04/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/","excerpt":"2021华为区块链高校大赛","text":"2021华为区块链高校大赛","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://dinosauryes.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"JAVA基础学习","slug":"JAVA基础学习","date":"2021-04-13T07:37:23.000Z","updated":"2021-06-24T13:46:46.100Z","comments":true,"path":"2021/04/13/JAVA基础学习/","link":"","permalink":"http://dinosauryes.github.io/2021/04/13/JAVA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"岁月悠悠 衰微只及肌肤，热忱抛却 颓废必至灵魂。**(已完结)**","text":"岁月悠悠 衰微只及肌肤，热忱抛却 颓废必至灵魂。**(已完结)** 面向对象 面向过程：当需要实现一个功能时，每一个具体的步骤都要亲力亲为，详细处理每一个细节 面向对象：当需要实现一个功能时，不关心具体的步骤，而是找一个以及具有该功能的，来帮我做 1234567891011121314151617import java.util.Arrays;public class main &#123; public static void main(String[] args) &#123; int[] array = &#123;1, 2, 3, 4, 5&#125;; System.out.print(&quot;[&quot;);//面向过程 for (int i = 0; i &lt; array.length; i++) &#123; if (i == array.length - 1) &#123; System.out.print(array[i] + &quot;]&quot;); &#125; else &#123; System.out.print(array[i] + &quot;,&quot;); &#125; &#125; System.out.println(&quot;========&quot;); System.out.println(Arrays.toString(array));//面向对象 &#125;&#125; 特点：面向对象符合我们思考习惯，可将复杂的事情简单化，并将我们从执行者变为指挥者，面向对象的语言中包含了三大基本特征，封装，继承，多态 面向对象三大特征： 封装封装在Java中的体现 ​ 1.方法就是一种封装 ​ 封装就是将一些细节信息隐藏起来，对于外界不可见 ​ 2.关键字private封装 ​ 一旦使用private进行修饰，那么本类当中仍然可以随意访问，超出本类范围之外就不能再直接访问 ​ 间接访问private成员变量，就是定义一对Getter/Setter方法 注意事项： ​ 1.当方法的局部变量和成员变量重名的时候，根据就近原则，优先使用局部变量，如果需要访问本类中的成员变量，需要使用格式： 1this.成员变量名 ​ 通过谁调用方法，谁就是this 继承 概述 继承主要解决的问题是共性抽取 子类可以拥有父类的内容，子类还可以拥有自己专有的内容 格式 在继承的关系中，子类就是一个父类，也就是说，子类可以被当作父类来看待 1.定义父类的格式 123public class 父类名称&#123; // ...&#125; 2.定义子类的格式 123public class 子类名称 extends 父类名称&#123; // ...&#125; 3.重名 在父子类继承关系当中，如果成员变量重名，创建对象时有两种方式 ​ 直接通过子类对象访问成员变量 ​ 间接通过成员方法访问成员变量 1234Zi zi = new Zi(); // 等号左边是谁，就优先用谁System.out.println(zi.num) // 没有则向上找System.out.println(fu.methodfu)System.out.println(zi.methodzi) // 优先用此方法的成员变量,没有则向上找 区分子类方法中重名的三种变量 ​ 局部变量：直接写 ​ 本类的成员变量：this.成员变量 ​ 父类的成员变量：super.成员变量 4.继承中成员方法的访问特点 创建的对象是谁，就优先用谁，如果没有则向上找 5.方法的覆盖重写(Override) ​ 概念： 在继承的关系中，方法的名称一样，参数列表也一样 ​ 重写(Override)：方法的名称一样，参数列表也一样 ​ 重载(Overload)：方法的名称一样，参数列表不一样 ​ 特点：创建的是子类对象，则优先用子类方法 6.继承中的构造方法的访问特点 ​ 1.子类构造方法中有一个默认隐含的“super( )”调用，所以一定是先调用的父类构造，后执行的子类构造 ​ 2.子类构造通过super关键字来调用父类重载构造 ​ 3.super的父类构造方法必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造 ​ 4.子类必须调用父类构造方法，不写则赠送super()，写了则用写的super重载调用 super关键字的三种用法 1.在子类的成员方法中，访问父类的成员变量 1super.num // 父类中的num成员变量 2.在子类的成员方法中，访问父类的成员方法 1super.method // 父类中的method成员方法 3.在子类的构造方法中，访问父类的构造方法 1super() // 第一行 仅一个 可重载 this关键字的三种用法 super关键字用来访问父类内容，而this关键字用来访问本类内容 1.在本类的成员方法中，访问本类的成员变量 1this.num // 本类中的成员变量 2.在本类的成员方法中，访问本类的另一个成员方法 1this.method() // 本类的另一个成员方法 3.在本类的构造方法中，访问本类的另一个构造方法 1this() // 访问本类的另一个构造方法，可重载，必须是构造方法的第一个语句 ​ 使用场景 对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容 Java继承的特点 1.java语言是单继承的 一个类的直接父类只能有唯一一个 2.java语言可以多级继承 java.lang.Object是祖宗类 3.一个子类的直接父类是唯一的，但是一个父类可以有很多个子类 注意事项 1.必须包装方法的名称相同，参数列表也相同，@Override写在方法前，用来检测是不是有效的正确覆盖重写 2.子类方法的返回值必须小于等于父类方法的返回值范围，Object类是所有类的公共最高父类 java.lang.String就是Object的子类 3.子类方法的权限必须大于等于父类方法的权限修饰符，public &gt; protected &gt; (default) &gt; private (default)不是关键字default，而是什么都不写，留空 4.无论成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类 5.super和this两种方法构造调用，不能同时使用 多态 概述 extends继承或者implements接口实现，是多态的前提 一个对象拥有多种形态就是对象的多态性 多态的格式和使用 代码中体现多态性：父类引用指向子类对象 12父类名称 对象名 = new 子类名称();接口名称 对象名 = new 实现类名称(); 访问成员变量 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找 多态中成员方法 new谁则优先用谁，没有则向上找 编译看左边，运行看右边 用处(好处) 无论右边new的时候换成哪个子类对象，等号左边的调用方法都不会变化 对象的上下转型 ​ 向上转型 1父类名称 对象名 = new 子类名称(); 右侧创建一个子类对象，把它当作父类看待使用 向上转型一定是安全的 从小范围转为大范围 弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容 ​ 向下转型(还原) 1子类名称 对象名 = (子类名称) 父类对象; 将父类对象还原为子类对象 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫 如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错 ​ 判断前面的对象能不能当后面类型的实例 1234对象 instanceof 类名称 // 将得到一个boolean值，可以判断前面的对象能不能当后面类型的实例 if(animal instanceof Dog)&#123; Dog dog = (Dog) animal; &#125; 匿名对象：只有右边的对象，无左边的名字和赋值运算符 1234Scanner sc = new Scanner(System.in)int num = sc.nextInt(); // 普通使用方式int num = new Scanner(System.in).nextInt(); // 匿名对象的方式methodParam(new Scanner(System.in)); // 使用匿名对象来传递参数 ​ 注意事项： 匿名对象只能使用唯一的一次，下次使用要再创建一个新对象 ​ 使用建议： 若确定一个对象只需要使用唯一的一次，就可以用匿名对象 静态static关键字​ 1.一旦使用static关键字这样的内容不再属于对象而是属于类，凡是本类的对象都都共享同一份 ​ 2.一旦使用static修饰成员方法，那么这就成了静态方法，静态方法不属于对象，而是属于类 ​ 3.若没有static关键字，那么必须首先创建对象，然后通过对象才能使用它 1234Student obj = new Student();obj.method(); // 没有static关键字，先创建obj.methodStatic(); // 正确，但不推荐，编译后会被Javac翻译为；类名称.静态方法名Student.methodStatic(); // 正确且推荐 ​ 4.静态不能直接访问非静态(内存中先有的静态内容，后有的非静态内容) ​ 5.静态方法不能用this关键字 静态代码块 12345public class 类名称&#123; static&#123; // 静态代码块内容 &#125;&#125; // 当第一次使用本类时，静态代码块执行唯一一次，执行优先于构造方法 用途 用来一次性的对静态成员变量进行赋值 final关键字用于修饰类 123public final class 类名称 &#123;&#125; 被final修饰的类不能有任何子类(不能作为父类) 用于修饰方法 当final关键字来修饰一个方法的时候，这个方法就是最终方法，不能被覆盖重写 用于修饰局部变量 一旦使用final关键字来修饰局部变量，那么这个变量就不能进行更改 对于基本类型来说不可变是变量当中的数据不可改变 对于引用数据类型来说不可变是变量当中的地址值不可改变 用于修饰成员变量 对于成员变量来说，如果使用final关键字修饰那么这个变量也是不可变的 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值 必须包装类当中所有重载的构造方法，都最终会对final的成员变量进行赋值 四种权限修饰符 public protected (default) private 同一个类 YES YES YES YES 同一个包 YES YES YES NO 不同包子类 YES YES NO NO 不同包非子类 YES NO NO NO (default)并不是关键字default 而是根本不写 内部类如果一个事物内部包含另一个事物那么这就是一个类内部包含另一个类 成员内部类 123456修饰符 class 外部类名称 &#123; 修饰符 class 内部类名称&#123; // ... &#125; // ...&#125; 内用外，随意访问；外用内，需要内部类对象 间接使用方式：在外部类的方法中，使用内部类；然后main只是调用外部类的方法 直接使用方式 1外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 内部类的同名变量访问 12345678910111213// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer&#123; int num = 10; public class Inner&#123; int num = 20; public void methodInner()&#123; int num = 30 System.out.println(num); // 内部类方法的局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 Systrm.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 局部内部类的定义 如果一个方法定义在一个方法内部的，那么这就是一个局部内部类 局部：只有当前所属方法才能使用它，出了这个方法外面就不能用了 1234567修饰符 class 外部类名称&#123; 修饰符 返回值类型 外部类方法名称()&#123; class 局部内部类名称&#123; // ... &#125; &#125;&#125; 定义一个类的时候，权限符修饰规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 final问题 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final(变量不能值不能改变) 备注：从Java 8+开始只要局部变量事实不变，那么final关键字可以省略 原因：1.new出来的在堆中 ​ 2.局部变量跟着方法走在栈内存中 ​ 3.方法运行结束后，立刻出栈，局部变量消失 ​ 4.new出来的对象会在堆当中持续存在，直到垃圾回收 匿名内部类 如果接口的实现类(或者父类的子类)只需要使用唯一的一次 那么在这种情况下可以省略掉该类的定义，改为使用匿名内部类 123接口名称 对象名 = new 接口名称()&#123; // 覆盖重写所有抽象方法&#125;; 对格式“new 接口名称(){…}”的解析 ​ 1.new代表创建对象的动作 ​ 2.接口名称就是匿名内部类需要实现哪个接口 ​ 3.{…}是匿名内部类的内容 注意事项 ​ 1.匿名内部类在创建对象时只能使用唯一的一次 如果希望多次创建对象，而且类的内容一样，那么必须使用单独定义的实现类 ​ 2.匿名对象在调用方法的时候只能使用唯一的一次 如果希望同一个对象调用多次方法，那么必须有对象名 ​ 3.匿名内部类是省略了实现类/子类，但是匿名对象是省略了对象名称 抽象 抽象方法 如果父类当中的方法不确定如何{}方法体的实现，那么这种方法叫抽象方法(eg：图像周长) 在返回值类型前加上abstract并去掉大括号，直接分号结束 1public abstract void eat(); // 抽象方法，代表吃，具体吃什么不确定 抽象类 抽象方法所在类，必须是抽象类才行，在class前加上abstract即可 1public abstract class Animal // 抽象类，里面可以有普通的成员方法 抽象方法和抽象类的使用 1.不能直接创建new抽象类对象 2.必须用一个子类来继承抽象父类 3.子类必须覆盖重写抽象父类当中所有的抽象方法 覆盖重写(实现)：子类去掉抽象方法的abstract关键字，然后补上方法体大括号 4.创建子类对象进行使用 注意事项 1.抽象类不能创建对象，如果创建，编译无法通过而保持，只能创建其非抽象子类的对象 2.抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的 3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定时抽象类 4.抽象类的子类，必须重写抽象父类的所有的抽象方法，否则编译无法通过而报错，除非该子类也是抽象类 接口 概述 接口就是多个类的公共规范 接口是一种引用数据类型。最重要的内容就是其中的抽象方法 定义格式 123public interface 接口名称 &#123; // 接口内容&#125; 接口内容可以包含：1.常量 2.抽象方法 3.默认方法 4.静态方法 5.私有方法 1.接口的抽象方法 定义 1234public abstract 返回值类型 方法名称(参数列表);public 返回值类型 方法名称(参数列表);abstract 返回值类型 方法名称(参数列表);返回值类型 方法名称(参数列表); // 接口的抽象方法省略写法 接口当中的抽象方法，修饰符必须是两个固定的关键字： public abstract 这两个关键字修饰符可以选择性省略 方法的三要素可以随意定义 使用 接口不能直接使用，必须有一个实现类来实现该接口 123public class 实现类名称 implements 接口名称&#123; // ...&#125; 2.接口的实现类必须覆盖重写(实现)接口中所有的抽象方法 覆盖重写(实现) 去掉abstract关键字，加上方法体大括号 3.创建实现类的对象，进行使用 4.注意：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个接口必须是抽象类 2.接口的默认方法 定义 123456public default 返回值类型 方法名称(参数列表)&#123; // ...&#125; // 默认方法可以有方法体default 返回值类型 方法名称(参数列表)&#123; //接口的默认方法省略写法 &#125; 接口当中的默认方法，可以解决接口升级的问题 使用 接口的默认方法，可以通过接口实现类对象，直接调用 接口的默认方法，也可以通过接口实现类进行覆盖重写 3.接口的静态方法 定义 从Java 8开始接口中允许当中允许定义静态方法 123456public static 返回值类型 方法名称(参数列表)&#123; // 方法体&#125;static 返回值类型 方法名称(参数列表)&#123; // 接口的静态方法省略写法 &#125; 使用 不能通过接口实现类的对象来调用接口当中的静态方法 通过接口名称直接调用其中的静态方法 接口名称.静态方法名(参数); 4.接口的私有方法 定义 普通私有方法，解决多个默认方法之间重复代码问题 123private 返回值类型 方法名称(参数列表)&#123; // 方法体&#125; 2.静态私有方法，解决多个静态方法之间重复代码问题 123private static 返回值类型 方法名称(参数列表)&#123; // 方法体&#125; 5.接口常量 定义 接口中可以定义“成员变量”，但是必须使用 public static final 三个关键字进行修饰 从效果上来看，这其实就是接口的常量 1public static final 数据类型 常量名称 = 数据值; 一旦使用final关键字进行修饰，说明不可改变 使用 接口中的常量可省略 public static final关键字 接口中的常量必须进行赋值 接口中常量的名称使用完全大写的字母，用下划线进行分割 1接口名称.常量名称 6.接口之间的多继承 类与类之间是单继承的，直接父类只有一个 类与接口之间是多实现的，一个类可以有多个接口 接口与接口之间是多继承的 多个父接口当中的抽象方法如果重复，没关系 多个父类接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，且带default关键字 注意事项 1.接口没有静态代码块和构造方法 2.一个类的直接父类是唯一的，但一个类可以同时实现多个接口 123public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB &#123; // 覆盖重写所有抽象方法&#125; 3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可 4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类 5.如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写 6.一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先用父类当中的方法 常量何为常量：程序运行期间固定不变的量。 常量的分类：​ 1.字符串常量：用“ “引起来的部分，eg：”HelloWorld”（双引号中可为空） ​ 2.整型常量：数字，无小数点，eg：100，-200，0 ​ 3.浮点数常量 : 数字，有小数点，eg：3.14，-56.00 ​ 4.字符常量：用’’引起来的部分，eg：’A’,’B’,’泽’（双引号中不为空）（java中允许使用中文字符） ​ 5.布尔常量：仅两种true,false ​ 6.空常量：null，代表没有任何数据。 数据类型基本数据类型整数型 byte short int long 浮点型 float double (近似值而非精确值) 字符型 char 布尔型 boolean 数据类型 关键字 内存占用 取值范围 字节型 byte 1字节 -128~127 短整型 short 2字节 -32768~32767 整形 int（默认类型） 4字节 -231~231-1 长整型 long 8字节 -263~263-1 单精度浮点数 float 4字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认类型） 8字节 4.9E-324~1.7977E+308 字符型 char 2字节 0~65535 布尔类型 boolean 1字节 true,false 注意事项： 1.数据范围与字节数不一定相关 2.浮点数当中默认类型是double。如果使用float类型，需要加上后缀F 3.整数中默认类型是int。如果一定要使用long类型，需要加上后缀L 引用数据类型字符串，数组，类(Scanner)，接口，Lambda 使用步骤： 1.导包 1import 包路径.类名称; 如果需要使用的目标类和当前类位于同一个包下，则可以省略导包语句不写 只有java.lang包下的内容不需要导包，其他都需要import语句 2.创建 1类名称 对象名 = new 类名称 3.使用 1对象名.成员方法名 数据类型转换 自动类型转换 特点：代码不需要特殊处理，自动完成 规则：数据范围从小到大 强制数类型转换： 特点：代码需要特殊格式处理，不能自动完成 格式： 1范围小的类型 范围小的变量名 &#x3D; （范围小的类型） 原本范围大的类型 注意事项： 1.强制类型转换不推荐使用，可能发生精度损失和数据溢出 12int num = (int) 6000000000L;System.out.println(num);// 1705032704 2.byte/short/char类型都可以发生数学运算 12char zifu = &#x27;A&#x27;;System.out.println(zifu + 1);// 66 3.byte/short/char类型运算时，首先提升成为int类型，再计算 4.Boolean类型不能发生数据类型转换 ASCII表： ASCII值 控制字符 48 0 65 A 97 a 变量何为变量： ​ 程序运行期间，可以改变的量 注意事项： ​ 1.如果创建多个变量，那么变量之间的名称不可以重复 ​ 2.对于float和long类型来说字母后缀F和L不要丢掉 ​ 3.如果使用byte和short类型的变量，右侧数据值范围不能超过左侧类型的范围 ​ 4.变量需要先赋值才能使用 ​ 5.变量使用不能超过作用域的范围 成员变量与局部变量的区别 ​ 1.定义的位置不一样 ​ 局部变量：在方法内部 ​ 成员变量：在方法外部，直接写在类中 ​ 2.作用范围不一样 ​ 局部变量：只有在方法中才可使用 ​ 成员变量：整个类通用 ​ 3.默认值不一样 ​ 局部变量：没有默认值，使用必须赋值 ​ 成员变量：有初始默认值(与数组一样) 123456public class main &#123; String name; // 成员变量 public static void main(String[] args) &#123; int num = 10; // 局部变量 &#125;&#125; ​ 4.内存的位置不一样 ​ 局部变量：位于栈内存，随方法进栈而诞生，随方法出栈而消失 ​ 成员变量：位于堆内存，随对象创建而诞生，随对象被垃圾回收而消失 类定义类 成员变量是直接定义在类中，在方法外面 成员方法不要写static关键字 对象的创建及其使用 ​ 通常情况下，一个类不能直接使用，需要创建一个对象才能使用 导包：指出所需要的类在什么位置 1import 包名称.类名称; ​ 对于和当前类属于同一个包的情况，可以省略导包语句不写 创建 1类名称 对象名 = new 类名称(); 使用 使用成员变量：对象名.成员变量名 使用成员方法：对象名.成员方法名() 注意事项：如果成员变量没有赋值会有一个初始值，规则和数组一样 类与对象的关系 类是对一类事物的描述，是抽象的 对象是一类对象的实例，是具体的 类是对象的模板，对象是类的实例 定义标准类： 组成部分 1.所有成员变量都要使用private关键字修饰 2.为每一个成员变量编写一对儿Getter/Setter方法 3.编写一个无参数构造方法 4.编写一个全参数构造方法 方法 何为方法： 将一个功能抽取出来，定义在一个大括号内，形成一个单独的功能。需要这个功能时，进行调用，实现了代码的复用性。 定义格式： 1234修饰符 返回值类型 方法名称 （参数类型 参数名称,...）&#123; 方法体 return 返回值;&#125; return 1.停止当前方法 2.将后面的返回值还给调用处 3.return后面的返回值要与 返回值类型 保持一致 4.对于有返回值的方法，可以使用单独调用，打印调用和赋值调用 5.对于无返回值的方法，只能进行单独调用 6.对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己 7.无返回值，对于方法当中最后一行的return可以省略不写 8.一个方法中可以有多个return语句，但是必须保证同时只有一个会被执行 注意事项： 1.方法定义的先后顺序无所谓 2.方法定义不能产生嵌套包含关系 3.方法执行需要调用 调用格式： 123方法名称（参数）;System.out.println(方法名称（参数）)数据类型 变量名称 = 方法名称（参数） 重载（OverLoad）多个方法的名称一样，但参数列表不一样 方法重载相关因素： 1.参数个数 2.参数类型 3.参数的多类型顺序 方法重载无关因素： 1.参数名称 2.方法的返回值类型 构造方法构造方法是专门用来创建对象的方法，当通过关键字new来创建对象时，其实就是再调用构造方法 创建格式： 123public 类名称(参数类型 参数名称)&#123;方法体&#125; 注意事项： 1.构造方法的名称必须和所在的类名称完全一样 2.构造方法不要写任何返回值类型，包括void 3.构造方法不能return一个具体返回值 4.如果没有编写任何构造方法，编译器默认编一个构造方法，无参数、方法体 一旦编写，方法体不再赠送构造方法 5.构造方法可以进行重载(方法名称相同，参数列表不同) 数组可以同时存放多个数据值 特点： 1.数组是一种引用数据类型 2.数据当中的多个数据，类型必须统一 3.数组的长度在程序运行期间不能改变 初始化方式： 1.动态初始化（指定长度） 1数据类型[] 数组名称 = new 数据类型[数组长度]; 2.静态初始化（指定内容） 12数据类型[] 数组名称 = new 数据类型[] &#123;元素1,元素2..&#125;;数据类型[] 数组名称 = &#123;元素1,元素2..&#125;; 注意事项 1.有new可以拆分成两个步骤 12int[] array;array = new int[] &#123;11,23,21&#125;; 2.静态初始化省略格式不能拆分成两个步骤 3.若不确定数组当中的具体内容，用动态初始化，反之则用静态初始化 使用数组中的元素 1.直接打印数组名称，得到的是数组对应的内存地址哈希值 2.访问数组元素的格式 数组名称[索引值]（从0开始） 3.使用动态初始化数组时，其中的元素会自动拥有一个默认值 如果为整数类型，默认值为0 如果为浮点类型，默认值为0.0 如果为字符类型，默认为‘\\u0000’ 如果为布尔类型，默认为false 如果为引用类型，默认为null 数组异常 数组索引越界异常 空指针异常(没new创建) 获取数组的长度 1int xxx = 数组名称.length; 得到一个int数字，代表数组的长度 数组一旦创建，程序运行期间长度不可改变 12345eg：int[] array = new int[3];System.out.println(array.length);//3array = new int[5];System.out.println(array.length);//5 数组的遍历输出 概念：对数组中的每个元素进行逐一处理(使用循环与数组长度) 1234for (int i = 0; i &lt; 数组名.length; i++) &#123; &#125;//快捷码：数组名.length.fori 数组作为方法的参数时，传递进去的是数组的地址 数组作为方法的返回值时，返回的是数组地址 语句判断语句单if 123if(关系表达式)&#123; 语句体;&#125; if - - else 12345if(关系表达式) &#123; 语句体1;&#125;else&#123; 语句体2;&#125; 多if - - else 1234567891011if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2)&#123; 执行语句2;&#125; ...&#125; else if (判断条件n) &#123; 执行语句n;&#125; else &#123; 执行语句n+1;&#125; 选择语句switch语句格式 123456789101112switch(表达式)&#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; switch注意事项 1.多个case后面的数值不可以重复 2.swich后面的小括号中只能是： 基本数据类型：byte/short/char/int 引用数据类型：String字符串，enum枚举 3.switch语句前后顺序可以颠倒，且break语句可以省略（匹配到case后从当前位置向下执行，直到遇到break或default） 循环语句1.初始化语句：在循环开始最初执行，并且只能做唯一一次。 2.条件判断：若成立，循环继续；反之则跳出循环。 3.循环体：重复要做的事情内容，若干行语句。 4.布进语句：每次循环之后的扫尾工作。 for循环 123for (初始表达式; 布尔表达式; 步进表达式)&#123; 循环体；&#125; while循环 while格式 12345初始化语句;while (条件判断)&#123; 循环体; 步进语句;&#125; do - - while 循环 do - - while 格式 12345初始化语句do &#123; 循环体 步进语句&#125; while (条件判断); 三种循环的区别 1.若条件判断从未满足，for和while循环执行0次，do-while循环至少执行一次 2.for循环的变量在小括号中定义，仅能在循环中使用。while循环和do-while循环初始化语句在括号外，循环结束后可以继续使用 3.凡是次数确定的场景多用for循环，否则用while循环 break关键字 1.可以用在switch语句中，一旦执行，整个switch语句立刻结束 2.可以用在循环语句中，一旦执行，整个循环语句立刻结束，打断循环 continue关键字 1.一旦执行，立刻跳过当前次循环内容，马上开始下一次循环 JAVA的内存划分1**.栈(Stack)：存放方法中的局部变量，运行方法一定要在栈中** ​ 局部变量：{}内的变量，一旦超出作用域，立刻从栈内存中消失 2.堆(Heap)：new出来的，在堆内存 ​ 堆内存里的东西都有一个地址值：16进制 ​ 堆内存里面的数据，都有默认值： ​ 若为整数 默认为0 ​ 若为浮点数 默认为0.0 ​ 若为字符 默认为‘\\u0000’ ​ 若为布尔 默认为false ​ 若为引用类型 默认为null 3.方法区(Method Area)：存储.class相关信息，包含方法的信息 4.本地方法栈(Native Method Stack)：与操作系统相关 5.寄存器(pc Register)：与CPU相关 API(Application Programming Interface)概述:Java API程序员小词典 Scanner类 何为Scanner类 可以解析基本类型和字符串的简单文本扫描器(实现键盘输入到程序中) Scanner的一般步骤 1.导包 2.创建 1Scanner sc = new Scanner(System.in); ​ System.in(键盘输入) 3.使用 123对象名.成员方法名int num = sc.nextInt(); // 获取键盘输入的一个int数字String str = sc.next(); // 获取键盘输入的一个字符串 Random类 何为Random类： 用于生成随机数字的包 Random的一般步骤： 1.导包 1import java.util.Random 2.创建 1Random r = new Random(); 3.使用 123int num = r.nextInt(); // 获取一个随机的int数字,有正负两种int num = r.nextInt(3); // 获取一个随机的int数字(参数代表范围，左闭右开区间) 范围为[0,3)int num = r.nextInt(n)+1; // 取值范围为[1,n] ArrayList类 何为ArrayList类 可以实现数组的大小可变，操作内部的储存 表示泛型(装在集合当中的所有元素，全部都是统一的类型(引用类型而非基础类型)) ArrayList的一般步骤 1.导包 1import java.util.ArrayList; 2.创建 从JDK1.7+开始，右侧的尖括号内部可以不写写内容，但&lt;&gt;本身还是要写的 1ArrayList&lt;数据类型&gt; list = new Arraylist&lt;&gt;(); 3.使用 ​ 1.向集合中添加元素: add 12345list.add(&quot;张三&quot;);list.add(&quot;赵四&quot;); // 向集合里添加一些数据System.out.println(list); // [张三，赵四]boolean success = list.add(&quot;王五&quot;);System.out.println(&quot;添加的动作是否成功：&quot;+ success); // 添加的动作是否成功：true ​ 2.从集合中获取元素：get 12String name = list.get(1); // 索引值从0开始System.out.println(&quot;第一号索引位置：&quot;+ name); // 第一号索引位置：赵四 ​ 3.从集合中删除元素：remove 123String whoremove = list.remove(1); // 返回值是被删除的人System.out.println(&quot;被删除的人是：&quot; + whoremove); // 赵四System.out.println(list); // [张三, 王五] ​ 4.获取集合的元素个数：size 12int size = list.size();System.out.println(size); // 2 5.遍历集合 123for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; // 快捷键 list.fori ​ 6.ArrayList集合存储基本数据类型、 如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的包装类 包装类：引用类型，包装类都位于java.lang包下，不需要导包 基本类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 123ArrayList&lt;Integer&gt; listA = new ArrayList;listA.add(100);System.out.println(listA.get(0)); // 100 从JDK1.5开始，支持自动装箱，自动拆箱 ​ 自动装箱：基本类型–&gt;包装类型 ​ 自动拆箱：包装类型–&gt;基本类型 ArrayList注意事项 对于ArrayList来说，直接打印得到的不是地址值，而是内容，若内容为空得到的时：[ ] String类 概述 Java程序中所有字符串字面值(如“abc”)都作为此类的实例实现 String类的一般步骤 1.特点 ​ 1.字符串是常量，内容永不可变 ​ 2.字符串可共享使用 ​ 3.字符串效果相当于是char[ ]字符数组，但是底层原理是byte[ ]字节数组 ​ 4.在java.lang.String包下不用导包 2.创建 常见3+1种方式 ​ 三种构造方法： 123public String() // 创建一个空白字符串，不含有任何内容public String(char[] array) // 根据字符数组的内容，来创建对象的字符串public String(bytr[] array) //根据字节数组的内容，来创建对应的字符串 ​ 一种直接创建： 1String str = &quot;Hello&quot;; // 右边直接用 3.使用 ​ 1.字符串内容的比较( 直接==是进行对象的地址值比较) 123456789public boolean equals(Object obj); // 任何对象都能用Object进行接受public boolean equalsIgnoreCase(Object obj); // 忽略大小写String str1 = &quot;Hello&quot;;char[] charArray = &#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;String str2 = new String(charArray);System.out.println(str1.equals(str2)); // trueSystem.out.println(str2.equals(&quot;Hello&quot;)); // trueSystem.out.printlb(&quot;Hello&quot;.equals(str1)); // true// 推荐：&quot;abc&quot;.equals(str) 不推荐：str.equals(&quot;abc&quot;) 原因是容易发生空指针异常 ​ 2.字符串获取相关 1234public int length() // 获取字符串当中含有的字符个数，拿到字符串长度public String concat(String str) // 将当前字符串和参数字符串拼接成为返回值新的字符串public char charAt(int index) // 获取指定索引(从零开始)位置的单个字符 如果没有返回-1public int indexOf(String str) // 查找字符串在本字符串当中首次出现的索引位置 ​ 3.字符串截取 12public String substring(int index) // 截取从参数位置一直到字符串末尾，返回新字符串public String substring(int begin,int end) // 截取从begin开始到end结束中间的字符串 [begin,end) ​ 4.相关转换 123public char[] toCharArray() // 将当前字符串拆分成为单个字符数组作为返回值public byte[] getBytes() // 获得当前字符串底层的字节数组public String replace(CharSequence oldString,CharSequence newString) // 将所有出现的老字符串替换成为新的字符串，返回替换之后的新字符串 ​ 5.字符串分割 12public String[] split(String regex) // 按照参数的规则，将字符串切分成为若干部分 //注意事项：split方法的参数是&quot;正则表达式&quot;，若按照英文句点&quot;.&quot;进行切分，必须写&quot;\\\\.&quot;(l) 注意事项： 1.对于引用数据类型来说， ==比较的是地址值 2.双引号直接写的字符串在常量池种，new不在池中 Arrays类 概述 提供一些与数组相关的工具类，提供了大量静态方法，用来实现数组常见的操作(静态方法不用new，直接类名称.方法名) Arrays使用 12345public static String toString(数组) // 将参数数组变成字符串(按照默认格式：[元素1, 元素2, ...])public static void sort(数组) // 按照默认升序(从小到大)对数组进行排序 /* 1.如果是数值，sort默认按照升序从小到大 2.如果是字符串，sort默认按照字母升序 3.如果是自定义类型，那么这个自定义的类需要有Comparable或Comparator接口的支持 */ Math类 概述 java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算线管的操作，多为静态方法。 Math类使用 12345public static double abs(double num) // 获取绝对值public static double ceil(double num) // 向上取整public static double floor(double num) // 向下取整[非四舍五入]public static long round(double num) // 四舍五入 Math.PI // d 注意事项 IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行内容，插入光标位置下面 Ctrl+Alt+L 格式化代码（使代码变工整） Ctrl+Shift+/ 多行注释，再按取消注释 Ctrl+/ 单行注释，再按取消注释 Alt+Ins 自动生成代码，toString,get,set等方法 Alt+Shift+上下箭头 移动当前代码行 Shift+F6 改变与之有关的所有参数名 快捷键 功能 Ctrl+方法名右键 查看方法源代码 Shift+F6 重命名光标所在的局部变量，重构名字 Fn+Alt+Insert 自动补全标准类 IDEA常用快捷代码 x.fori for(int i = 0; i &lt; 5; i++) pswm public static void main(String args) sout System.out.println() 一些小细节 &amp; 称为逻辑与，只有两个操作数都是true，结果才是true。 &amp;&amp; 称为简洁与或者短路与，也是只有两个操作数都是true，结果才是true。但是如果左边操作数为false，就不计算右边的表达式，直接得出false。类似于短路了右边。 | 称为逻辑或，只有两个操作数都是false，结果才是false。 || 称为简洁或或者短路或，也是只有两个操作数都是false，结果才是false。但是如果左边操作数为true，就不计算右边的表达式，直接得出true。类似于短路了右边。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://dinosauryes.github.io/tags/JAVA/"}]},{"title":"记录Hexo博客的创建","slug":"记录Hexo博客的创建","date":"2021-01-06T02:15:14.000Z","updated":"2021-01-07T11:30:23.897Z","comments":true,"path":"2021/01/06/记录Hexo博客的创建/","link":"","permalink":"http://dinosauryes.github.io/2021/01/06/%E8%AE%B0%E5%BD%95Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"​ 经历了数次失败，现开门见山的讲述使用Github 和 Hexo 搭建属于自己的博客","text":"​ 经历了数次失败，现开门见山的讲述使用Github 和 Hexo 搭建属于自己的博客 准备工作安装Node.js通过官网下载或下载学长发的安装包解压Node.js安装包即可 安装Git通过官网下载或下载学长发的安装包解压GIT安装包即可 检查GIT是否安装成功找到GIT对应文件夹 找到git-bash并打开 输入： 123git --versionnode -vnpm -v 若有提示对应的版本号，则Git安装成功！ 注册Github账号进入GitHub官网 点击 sign up注册账号（人机验证或许需要科学上网？可通过安装浏览器插件解决） 此时GitHub会向你的邮箱发送验证电子邮箱地址，点击确认。 创建repository点击new repository 注意repository name 是 你的github账号名.github.io 勾选Add a README file 点击creating repository.创建仓库 安装本地Hexo新建文件夹首先在你想要在本地放blog的地方新建blog文件夹 并对文件夹右键 点击Git Bash Here(功能类似与cd blog) 安装hexo输入： 12npm install hexo-cli -gnpm install hexo-deployer-git --save 输入： 12rm -rf * （此语句的作用是清空当前目录下的所有东西,谨慎使用，一定要在对应的blog下。）hexo init 检验效果（预览blog）下面来检验一下效果： 12hexo ghexo s 若git提示下列代码则说明成功： 1INFO Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop. 在浏览器输入 http://localhost:4000/ 查看预览效果（Ctrl+C可以关闭预览） 如果显示预览效果是 404 那么大概率是端口被占用了 再换一个端口试试看： 1hexo s -p 5000 此时本地blog就搭建好了，但只能自己访问。我们需要将blog部署到github上，来让更多人访问到我们的blog。 将hexo部署至github配置SSH密钥对blog文件夹右键，点击Git Bash Here 输入： 1ssh-keygen -t rsa -C &quot;your email@example.com&quot; 注：”your &#101;&#x6d;&#97;&#x69;&#x6c;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;“ 是你的邮箱，eg: 1ssh-keygen -t rsa -C &quot;xxx@qq.com&quot; 接下来连续按三次回车，会出现一系列字符串 运行以下命令: 1clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub 将密钥保存至粘贴板 或打开.ssh/id_rsa.pub文件直接复制密钥 在github账户上添加密钥此处因没有图片 自行百度 测试是否成功输入： 1ssh -T git@github.com 接着会提示你 1Are you sure you want to continue connecting(yes&#x2F;no)? 输入yes 若提示 1Hi 你的用户名！You&#39;ve successfully.... 配置git个人信息输入： 12git config --global user.name &quot;此处填你的用户名&quot; git config --global user.email &quot;此处填你的邮箱&quot; 此时本机已经成功与github连接 将本地的 Hexo 文件更新到 Github 中修改_config.yml文件配置用编程软件打开_config.yml（记事本也可以） 我这里用的是vs 找到关键字deploy(在最下面) 注意：”：“后要空一格 1234deploy: type: git repository: git@github.com:dinosauryes&#x2F;dinosauryes.github.io.git branch: main repository比葫芦画瓢将dinosauryes改为自己的github用户名 安装deployer在命令框中输入： 12npm install hexo-deployer-git --savehexo g -d 测试在网址输入https://你的GitHub用户名.github.io 完成 心得：不要轻言放弃！！！我重新安装了三次终于成功了。岁月悠悠 衰微只及肌肤热忱抛却 颓废必至灵魂","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://dinosauryes.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-06T00:09:37.897Z","updated":"2021-01-06T00:09:37.897Z","comments":true,"path":"2021/01/06/hello-world/","link":"","permalink":"http://dinosauryes.github.io/2021/01/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://dinosauryes.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"JAVA","slug":"JAVA","permalink":"http://dinosauryes.github.io/tags/JAVA/"},{"name":"教程","slug":"教程","permalink":"http://dinosauryes.github.io/tags/%E6%95%99%E7%A8%8B/"}]}